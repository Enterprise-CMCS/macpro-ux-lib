{"version":3,"file":"818.1e1548a9.iframe.bundle.js","mappings":";;AAyMA;;;;;;;;;;;AAYA","sources":["webpack://@enterprise-cmcs/macpro-ux-lib/./node_modules/@uswds/uswds/packages/usa-table/src/index.js"],"sourcesContent":["const select = require(\"../../uswds-core/src/js/utils/select\");\nconst behavior = require(\"../../uswds-core/src/js/utils/behavior\");\nconst { CLICK } = require(\"../../uswds-core/src/js/events\");\nconst { prefix: PREFIX } = require(\"../../uswds-core/src/js/config\");\nconst Sanitizer = require(\"../../uswds-core/src/js/utils/sanitizer\");\n\nconst TABLE = `.${PREFIX}-table`;\nconst SORTED = \"aria-sort\";\nconst ASCENDING = \"ascending\";\nconst DESCENDING = \"descending\";\nconst SORT_OVERRIDE = \"data-sort-value\";\nconst SORT_BUTTON_CLASS = `${PREFIX}-table__header__button`;\nconst SORT_BUTTON = `.${SORT_BUTTON_CLASS}`;\nconst SORTABLE_HEADER = `th[data-sortable]`;\nconst ANNOUNCEMENT_REGION = `.${PREFIX}-table__announcement-region[aria-live=\"polite\"]`;\n\n/** Gets the data-sort-value attribute value, if provided — otherwise, gets\n * the innerText or textContent — of the child element (HTMLTableCellElement)\n * at the specified index of the given table row\n *\n * @param {number} index\n * @param {array<HTMLTableRowElement>} tr\n * @return {boolean}\n */\nconst getCellValue = (tr, index) =>\n  tr.children[index].getAttribute(SORT_OVERRIDE) ||\n  tr.children[index].innerText ||\n  tr.children[index].textContent;\n\n/**\n * Compares the values of two row array items at the given index, then sorts by the given direction\n * @param {number} index\n * @param {string} direction\n * @return {boolean}\n */\nconst compareFunction = (index, isAscending) => (thisRow, nextRow) => {\n  // get values to compare from data attribute or cell content\n  const value1 = getCellValue(isAscending ? thisRow : nextRow, index);\n  const value2 = getCellValue(isAscending ? nextRow : thisRow, index);\n\n  // if neither value is empty, and if both values are already numbers, compare numerically\n  if (\n    value1 &&\n    value2 &&\n    !Number.isNaN(Number(value1)) &&\n    !Number.isNaN(Number(value2))\n  ) {\n    return value1 - value2;\n  }\n  // Otherwise, compare alphabetically based on current user locale\n  return value1.toString().localeCompare(value2, navigator.language, {\n    numeric: true,\n    ignorePunctuation: true,\n  });\n};\n\n/**\n * Get an Array of column headers elements belonging directly to the given\n * table element.\n * @param {HTMLTableElement} table\n * @return {array<HTMLTableHeaderCellElement>}\n */\nconst getColumnHeaders = (table) => {\n  const headers = select(SORTABLE_HEADER, table);\n  return headers.filter((header) => header.closest(TABLE) === table);\n};\n\n/**\n * Update the button label within the given header element, resetting it\n * to the default state (ready to sort ascending) if it's no longer sorted\n * @param {HTMLTableHeaderCellElement} header\n */\nconst updateSortLabel = (header) => {\n  const headerName = header.innerText;\n  const sortedAscending = header.getAttribute(SORTED) === ASCENDING;\n  const isSorted =\n    header.getAttribute(SORTED) === ASCENDING ||\n    header.getAttribute(SORTED) === DESCENDING ||\n    false;\n  const headerLabel = `${headerName}', sortable column, currently ${\n    isSorted\n      ? `${sortedAscending ? `sorted ${ASCENDING}` : `sorted ${DESCENDING}`}`\n      : \"unsorted\"\n  }`;\n  const headerButtonLabel = `Click to sort by ${headerName} in ${\n    sortedAscending ? DESCENDING : ASCENDING\n  } order.`;\n  header.setAttribute(\"aria-label\", headerLabel);\n  header.querySelector(SORT_BUTTON).setAttribute(\"title\", headerButtonLabel);\n};\n\n/**\n * Remove the aria-sort attribute on the given header element, and reset the label and button icon\n * @param {HTMLTableHeaderCellElement} header\n */\nconst unsetSort = (header) => {\n  header.removeAttribute(SORTED);\n  updateSortLabel(header);\n};\n\n/**\n * Sort rows either ascending or descending, based on a given header's aria-sort attribute\n * @param {HTMLTableHeaderCellElement} header\n * @param {boolean} isAscending\n * @return {boolean} true\n */\nconst sortRows = (header, isAscending) => {\n  header.setAttribute(SORTED, isAscending === true ? DESCENDING : ASCENDING);\n  updateSortLabel(header);\n\n  const tbody = header.closest(TABLE).querySelector(\"tbody\");\n\n  // We can use Array.from() and Array.sort() instead once we drop IE11 support, likely in the summer of 2021\n  //\n  // Array.from(tbody.querySelectorAll('tr').sort(\n  //   compareFunction(\n  //     Array.from(header.parentNode.children).indexOf(header),\n  //     !isAscending)\n  //   )\n  // .forEach(tr => tbody.appendChild(tr) );\n\n  // [].slice.call() turns array-like sets into true arrays so that we can sort them\n  const allRows = [].slice.call(tbody.querySelectorAll(\"tr\"));\n  const allHeaders = [].slice.call(header.parentNode.children);\n  const thisHeaderIndex = allHeaders.indexOf(header);\n  allRows.sort(compareFunction(thisHeaderIndex, !isAscending)).forEach((tr) => {\n    [].slice\n      .call(tr.children)\n      .forEach((td) => td.removeAttribute(\"data-sort-active\"));\n    tr.children[thisHeaderIndex].setAttribute(\"data-sort-active\", true);\n    tbody.appendChild(tr);\n  });\n\n  return true;\n};\n\n/**\n * Update the live region immediately following the table whenever sort changes.\n * @param {HTMLTableElement} table\n * @param {HTMLTableHeaderCellElement} sortedHeader\n */\n\nconst updateLiveRegion = (table, sortedHeader) => {\n  const caption = table.querySelector(\"caption\").innerText;\n  const sortedAscending = sortedHeader.getAttribute(SORTED) === ASCENDING;\n  const headerLabel = sortedHeader.innerText;\n  const liveRegion = table.nextElementSibling;\n  if (liveRegion && liveRegion.matches(ANNOUNCEMENT_REGION)) {\n    const sortAnnouncement = `The table named \"${caption}\" is now sorted by ${headerLabel} in ${\n      sortedAscending ? ASCENDING : DESCENDING\n    } order.`;\n    liveRegion.innerText = sortAnnouncement;\n  } else {\n    throw new Error(\n      `Table containing a sortable column header is not followed by an aria-live region.`\n    );\n  }\n};\n\n/**\n * Toggle a header's sort state, optionally providing a target\n * state.\n *\n * @param {HTMLTableHeaderCellElement} header\n * @param {boolean?} isAscending If no state is provided, the current\n * state will be toggled (from false to true, and vice-versa).\n */\nconst toggleSort = (header, isAscending) => {\n  const table = header.closest(TABLE);\n  let safeAscending = isAscending;\n  if (typeof safeAscending !== \"boolean\") {\n    safeAscending = header.getAttribute(SORTED) === ASCENDING;\n  }\n\n  if (!table) {\n    throw new Error(`${SORTABLE_HEADER} is missing outer ${TABLE}`);\n  }\n\n  safeAscending = sortRows(header, isAscending);\n\n  if (safeAscending) {\n    getColumnHeaders(table).forEach((otherHeader) => {\n      if (otherHeader !== header) {\n        unsetSort(otherHeader);\n      }\n    });\n    updateLiveRegion(table, header);\n  }\n};\n\n/**\n ** Inserts a button with icon inside a sortable header\n * @param {HTMLTableHeaderCellElement} header\n */\n\nconst createHeaderButton = (header) => {\n  const buttonEl = document.createElement(\"button\");\n  buttonEl.setAttribute(\"tabindex\", \"0\");\n  buttonEl.classList.add(SORT_BUTTON_CLASS);\n  // ICON_SOURCE\n  buttonEl.innerHTML = Sanitizer.escapeHTML`\n  <svg class=\"${PREFIX}-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n    <g class=\"descending\" fill=\"transparent\">\n      <path d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\" />\n    </g>\n    <g class=\"ascending\" fill=\"transparent\">\n      <path transform=\"rotate(180, 12, 12)\" d=\"M17 17L15.59 15.59L12.9999 18.17V2H10.9999V18.17L8.41 15.58L7 17L11.9999 22L17 17Z\" />\n    </g>\n    <g class=\"unsorted\" fill=\"transparent\">\n      <polygon points=\"15.17 15 13 17.17 13 6.83 15.17 9 16.58 7.59 12 3 7.41 7.59 8.83 9 11 6.83 11 17.17 8.83 15 7.42 16.41 12 21 16.59 16.41 15.17 15\"/>\n    </g>\n  </svg>\n  `;\n  header.appendChild(buttonEl);\n  updateSortLabel(header);\n};\n\nconst table = behavior(\n  {\n    [CLICK]: {\n      [SORT_BUTTON](event) {\n        event.preventDefault();\n        toggleSort(\n          event.target.closest(SORTABLE_HEADER),\n          event.target.closest(SORTABLE_HEADER).getAttribute(SORTED) ===\n            ASCENDING\n        );\n      },\n    },\n  },\n  {\n    init(root) {\n      const sortableHeaders = select(SORTABLE_HEADER, root);\n      sortableHeaders.forEach((header) => createHeaderButton(header));\n\n      const firstSorted = sortableHeaders.filter(\n        (header) =>\n          header.getAttribute(SORTED) === ASCENDING ||\n          header.getAttribute(SORTED) === DESCENDING\n      )[0];\n      if (typeof firstSorted === \"undefined\") {\n        // no sortable headers found\n        return;\n      }\n      const sortDir = firstSorted.getAttribute(SORTED);\n      if (sortDir === ASCENDING) {\n        toggleSort(firstSorted, true);\n      } else if (sortDir === DESCENDING) {\n        toggleSort(firstSorted, false);\n      }\n    },\n    TABLE,\n    SORTABLE_HEADER,\n    SORT_BUTTON,\n  }\n);\n\nmodule.exports = table;\n"],"names":[],"sourceRoot":""}